# tabgen - technical documentation
In this document, we explain the technical design and architecture of the tabgen tablature generation system.

## Running the system
To run the system, ...
1. Make sure your tablature files are split into the folders _training\_input_ and _evaluation\_input_.
1. Edit the enumeration class _tabgen.definitions.FeatureConfig_ to support the desired instrument and features.
1. Make sure that _tabgen.definitions.Path.MSCORE_ points to a working installation of MuseScore or MuseScore portable.
1. Run the _do\_preprocessing_ script.
1. Run the _estimate\_accuracy_. You may alternatively want to use _run\_sample_ or make a copy of it and adjust the settings.

## The _tabgen_ package
The tabgen package consist of the following six modules:

### tabgen.definititions
This is the basic configuration file, containing global settings.

The enumeration class _Path_ contains file paths as strings. _Path.MSCORE_ has to point to an executable binary file of _MuseScore_ in order for the system to work with input files other than \*.mscx.

The enumeration class _FeatureConfig_ contains the configuration of features to extract from training data and to use during evaluation time. A short info is given inline. For detailed information on the features, please refer to the project report.

### tabgen.preprocessing
The preprocessing module defines functions for batch-processing of tablatures, turning them into usable training data. Simply run this module using the do\_preprocessing executable.

### tabgen.base
A collection of base classes:
* ChordFrettingEvaluatorBase: The abstract base class for any evaluator. If you wish to add a new evaluator, e.g. a hand-tuned heuristic, inherit from this class and implement the _evaluate(fretting)_ method.
* StringConfigBase: An abstract class for StringConfig, to detach dependencies a little bit
* PruningConfig: A configuration object for pruning in the tree search.

### tabgen.modelling
This is the core package, modelling the nature of the guitar fretting problem. We conceptually divide classes into _pitch view_, capturing the musical intention or output, and _fretting view_, capturing the mechanics of the fretboard.

_Pitch view_ and _fretting view_ are connected by the _StringConfig_ class, which defines the strings and frets of an instrument. Conceptually, an object from the _fretting view_ can be applied to a _StringConfig_, yielding an object in _Pitch view_. Similarly, the _StringConfig_ can be used to generate possible _fretting view_ objects from a _pitch view_ object.
The implementation of _StringConfig_ pre-defines some typical instruments, e.g. _StringConfig.STANDARD\_24\_FRETS_ for a six-string guitar with 24 frets in standard tuning.

The following _pitch view_ classes are implemented:
* Pitch: represents a single pitch. The pitch class is based on the MIDI integer representation, but can generate note names with the method _get\_note\_name()_. It can further produce viable _NoteFretting_s with the method _get\_note\_frettings(string\_config)_.
* Chord: A chord is implemented as a collection of _Pitch_es and a duration. It can produce viable _ChordFretting_s with the method _get\_note\_frettings(string\_config, ...)_.

The following _fretting view_ classes are implemented:
* NoteFretting: Captures a single note fretting, defined by a combination of string and fret. The corresponding _Pitch_ object can be generated by calling _get\_pitch(string\_config)_.
* ChordFretting: Captures a fretting of a _Chord_. _ChordFretting_ can be understood as the main class in _tabgen.modelling_.
    * The features are extracted in this class and are available through the property _ChordFretting.features_.
    * The property _ChordFretting.cost_ captures the cost of the fretting, depending on the evaluator (class _ChordFrettingEvaluatorBase_) the _ChordFretting_ was initialised with.
    * The property _next\_pitches_ implements the pitch lookahead feature for LSTM predictions.
    * The property _previous_ can be used to traverse backwards in a tree of _ChordFrettings_.
    * The method _get\_chord(string\_config)_ yields the associated chord.
* ChordFrettingSequence: A sequence of _ChordFretting_s, i.e. a potential tablature. Offers a simple text tablature printout with _to\_ascii\_tab()_ and implements the model-based aspects of the tree search implemented by _tabgen.processing.Solver_.
    
### tabgen.evaluation
The evaluation module is a collection of evaluation classes, i.e. subclasses of _tabgen.base.ChordFrettingEvaluatorBase_ which return a cost function tabgen will optimise for. This can either be a direct cost estimate, or another measure -- in the case of LSTMChordFrettingEvaluator, for example, the cost function is the distance between predicted fretting and the possible fretting. For the latter case, make sure to set your _PruningConfig_ to (0,1,0,1). This effectively disables the tree search and selects the best fit at every time step.

### tabgen.processing
This module implements two classes tying the whole system together:
* Parser: Parse MuseScore XML files to an internal class construct with _parse(file\_path)_ or write a previously parsed class construct back to an XML file with _save(file\_path)_. Note that _save_ does not generate a new file, but copy the existing structure and change only the tablature to the generated one. The parser is only fully tested with XML files converted from Guitar Pro with MuseScore 2.0.3.
* Solver: The _Solver_ implements the tree search used to find the best fretting sequence for a chord sequence input. Call _Solver.solve(chord\_sequence, string\_config)_ to create a new tablature from a list of _Chord_s, or use _Solver.solve\_multi(...)_ to process a batch of input files with the tablature generator.


## Executables
* do\_preprocessing: Scans files in _Path.TRAINING\_INPUT_ and generates a training data file _Path.FEATURE_FILE_
* estimate\_accuracy: trains models on _Path.FEATURE_FILE_ and evaluates them. Change the _evaluators_ dictionary to select or define the models to train. Note that only one cost neural network and one direct prediction network can be trained at a time.
* run\_sample: Use this file as a skeleton for your own tests.